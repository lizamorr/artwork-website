{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _asap = require('asap');\n\nvar _asap2 = _interopRequireDefault(_asap);\n\nvar _generate = require('./generate');\n\nvar _util = require('./util'); // The current <style> tag we are inserting into, or null if we haven't\n// inserted anything yet. We could find this each time using\n// `document.querySelector(\"style[data-aphrodite\"])`, but holding onto it is\n// faster.\n\n\nvar styleTag = null; // Inject a string of styles into a <style> tag in the head of the document. This\n// will automatically create a style tag and then continue to use it for\n// multiple injections. It will also use a style tag with the `data-aphrodite`\n// tag on it if that exists in the DOM. This could be used for e.g. reusing the\n// same style tag that server-side rendering inserts.\n\nvar injectStyleTag = function injectStyleTag(cssContents) {\n  if (styleTag == null) {\n    // Try to find a style tag with the `data-aphrodite` attribute first.\n    styleTag = document.querySelector(\"style[data-aphrodite]\"); // If that doesn't work, generate a new style tag.\n\n    if (styleTag == null) {\n      // Taken from\n      // http://stackoverflow.com/questions/524696/how-to-create-a-style-tag-with-javascript\n      var head = document.head || document.getElementsByTagName('head')[0];\n      styleTag = document.createElement('style');\n      styleTag.type = 'text/css';\n      styleTag.setAttribute(\"data-aphrodite\", \"\");\n      head.appendChild(styleTag);\n    }\n  }\n\n  if (styleTag.styleSheet) {\n    styleTag.styleSheet.cssText += cssContents;\n  } else {\n    styleTag.appendChild(document.createTextNode(cssContents));\n  }\n}; // Custom handlers for stringifying CSS values that have side effects\n// (such as fontFamily, which can cause @font-face rules to be injected)\n\n\nvar stringHandlers = {\n  // With fontFamily we look for objects that are passed in and interpret\n  // them as @font-face rules that we need to inject. The value of fontFamily\n  // can either be a string (as normal), an object (a single font face), or\n  // an array of objects and strings.\n  fontFamily: function fontFamily(val) {\n    if (Array.isArray(val)) {\n      return val.map(fontFamily).join(\",\");\n    } else if (typeof val === \"object\") {\n      injectStyleOnce(val.fontFamily, \"@font-face\", [val], false);\n      return '\"' + val.fontFamily + '\"';\n    } else {\n      return val;\n    }\n  },\n  // With animationName we look for an object that contains keyframes and\n  // inject them as an `@keyframes` block, returning a uniquely generated\n  // name. The keyframes object should look like\n  //  animationName: {\n  //    from: {\n  //      left: 0,\n  //      top: 0,\n  //    },\n  //    '50%': {\n  //      left: 15,\n  //      top: 5,\n  //    },\n  //    to: {\n  //      left: 20,\n  //      top: 20,\n  //    }\n  //  }\n  // TODO(emily): `stringHandlers` doesn't let us rename the key, so I have\n  // to use `animationName` here. Improve that so we can call this\n  // `animation` instead of `animationName`.\n  animationName: function animationName(val) {\n    if (typeof val !== \"object\") {\n      return val;\n    } // Generate a unique name based on the hash of the object. We can't\n    // just use the hash because the name can't start with a number.\n    // TODO(emily): this probably makes debugging hard, allow a custom\n    // name?\n\n\n    var name = 'keyframe_' + (0, _util.hashObject)(val); // Since keyframes need 3 layers of nesting, we use `generateCSS` to\n    // build the inner layers and wrap it in `@keyframes` ourselves.\n\n    var finalVal = '@keyframes ' + name + '{';\n    Object.keys(val).forEach(function (key) {\n      finalVal += (0, _generate.generateCSS)(key, [val[key]], stringHandlers, false);\n    });\n    finalVal += '}';\n    injectGeneratedCSSOnce(name, finalVal);\n    return name;\n  }\n}; // This is a map from Aphrodite's generated class names to `true` (acting as a\n// set of class names)\n\nvar alreadyInjected = {}; // This is the buffer of styles which have not yet been flushed.\n\nvar injectionBuffer = \"\"; // A flag to tell if we are already buffering styles. This could happen either\n// because we scheduled a flush call already, so newly added styles will\n// already be flushed, or because we are statically buffering on the server.\n\nvar isBuffering = false;\n\nvar injectGeneratedCSSOnce = function injectGeneratedCSSOnce(key, generatedCSS) {\n  if (!alreadyInjected[key]) {\n    if (!isBuffering) {\n      // We should never be automatically buffering on the server (or any\n      // place without a document), so guard against that.\n      if (typeof document === \"undefined\") {\n        throw new Error(\"Cannot automatically buffer without a document\");\n      } // If we're not already buffering, schedule a call to flush the\n      // current styles.\n\n\n      isBuffering = true;\n      (0, _asap2['default'])(flushToStyleTag);\n    }\n\n    injectionBuffer += generatedCSS;\n    alreadyInjected[key] = true;\n  }\n};\n\nvar injectStyleOnce = function injectStyleOnce(key, selector, definitions, useImportant) {\n  if (!alreadyInjected[key]) {\n    var generated = (0, _generate.generateCSS)(selector, definitions, stringHandlers, useImportant);\n    injectGeneratedCSSOnce(key, generated);\n  }\n};\n\nexports.injectStyleOnce = injectStyleOnce;\n\nvar reset = function reset() {\n  injectionBuffer = \"\";\n  alreadyInjected = {};\n  isBuffering = false;\n  styleTag = null;\n};\n\nexports.reset = reset;\n\nvar startBuffering = function startBuffering() {\n  if (isBuffering) {\n    throw new Error(\"Cannot buffer while already buffering\");\n  }\n\n  isBuffering = true;\n};\n\nexports.startBuffering = startBuffering;\n\nvar flushToString = function flushToString() {\n  isBuffering = false;\n  var ret = injectionBuffer;\n  injectionBuffer = \"\";\n  return ret;\n};\n\nexports.flushToString = flushToString;\n\nvar flushToStyleTag = function flushToStyleTag() {\n  var cssContent = flushToString();\n\n  if (cssContent.length > 0) {\n    injectStyleTag(cssContent);\n  }\n};\n\nexports.flushToStyleTag = flushToStyleTag;\n\nvar getRenderedClassNames = function getRenderedClassNames() {\n  return Object.keys(alreadyInjected);\n};\n\nexports.getRenderedClassNames = getRenderedClassNames;\n\nvar addRenderedClassNames = function addRenderedClassNames(classNames) {\n  classNames.forEach(function (className) {\n    alreadyInjected[className] = true;\n  });\n};\n\nexports.addRenderedClassNames = addRenderedClassNames;\n/**\n * Inject styles associated with the passed style definition objects, and return\n * an associated CSS class name.\n *\n * @param {boolean} useImportant If true, will append !important to generated\n *     CSS output. e.g. {color: red} -> \"color: red !important\".\n * @param {Object[]} styleDefinitions style definition objects as returned as\n *     properties of the return value of StyleSheet.create().\n */\n\nvar injectAndGetClassName = function injectAndGetClassName(useImportant, styleDefinitions) {\n  // Filter out falsy values from the input, to allow for\n  // `css(a, test && c)`\n  var validDefinitions = styleDefinitions.filter(function (def) {\n    return def;\n  }); // Break if there aren't any valid styles.\n\n  if (validDefinitions.length === 0) {\n    return \"\";\n  }\n\n  var className = validDefinitions.map(function (s) {\n    return s._name;\n  }).join(\"-o_O-\");\n  injectStyleOnce(className, '.' + className, validDefinitions.map(function (d) {\n    return d._definition;\n  }), useImportant);\n  return className;\n};\n\nexports.injectAndGetClassName = injectAndGetClassName;","map":{"version":3,"sources":["/Users/liza/Documents/GitHub/artwork-website/art/node_modules/aphrodite/lib/inject.js"],"names":["Object","defineProperty","exports","value","_interopRequireDefault","obj","__esModule","_asap","require","_asap2","_generate","_util","styleTag","injectStyleTag","cssContents","document","querySelector","head","getElementsByTagName","createElement","type","setAttribute","appendChild","styleSheet","cssText","createTextNode","stringHandlers","fontFamily","val","Array","isArray","map","join","injectStyleOnce","animationName","name","hashObject","finalVal","keys","forEach","key","generateCSS","injectGeneratedCSSOnce","alreadyInjected","injectionBuffer","isBuffering","generatedCSS","Error","flushToStyleTag","selector","definitions","useImportant","generated","reset","startBuffering","flushToString","ret","cssContent","length","getRenderedClassNames","addRenderedClassNames","classNames","className","injectAndGetClassName","styleDefinitions","validDefinitions","filter","def","s","_name","d","_definition"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n    value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _asap = require('asap');\n\nvar _asap2 = _interopRequireDefault(_asap);\n\nvar _generate = require('./generate');\n\nvar _util = require('./util');\n\n// The current <style> tag we are inserting into, or null if we haven't\n// inserted anything yet. We could find this each time using\n// `document.querySelector(\"style[data-aphrodite\"])`, but holding onto it is\n// faster.\nvar styleTag = null;\n\n// Inject a string of styles into a <style> tag in the head of the document. This\n// will automatically create a style tag and then continue to use it for\n// multiple injections. It will also use a style tag with the `data-aphrodite`\n// tag on it if that exists in the DOM. This could be used for e.g. reusing the\n// same style tag that server-side rendering inserts.\nvar injectStyleTag = function injectStyleTag(cssContents) {\n    if (styleTag == null) {\n        // Try to find a style tag with the `data-aphrodite` attribute first.\n        styleTag = document.querySelector(\"style[data-aphrodite]\");\n\n        // If that doesn't work, generate a new style tag.\n        if (styleTag == null) {\n            // Taken from\n            // http://stackoverflow.com/questions/524696/how-to-create-a-style-tag-with-javascript\n            var head = document.head || document.getElementsByTagName('head')[0];\n            styleTag = document.createElement('style');\n\n            styleTag.type = 'text/css';\n            styleTag.setAttribute(\"data-aphrodite\", \"\");\n            head.appendChild(styleTag);\n        }\n    }\n\n    if (styleTag.styleSheet) {\n        styleTag.styleSheet.cssText += cssContents;\n    } else {\n        styleTag.appendChild(document.createTextNode(cssContents));\n    }\n};\n\n// Custom handlers for stringifying CSS values that have side effects\n// (such as fontFamily, which can cause @font-face rules to be injected)\nvar stringHandlers = {\n    // With fontFamily we look for objects that are passed in and interpret\n    // them as @font-face rules that we need to inject. The value of fontFamily\n    // can either be a string (as normal), an object (a single font face), or\n    // an array of objects and strings.\n    fontFamily: function fontFamily(val) {\n        if (Array.isArray(val)) {\n            return val.map(fontFamily).join(\",\");\n        } else if (typeof val === \"object\") {\n            injectStyleOnce(val.fontFamily, \"@font-face\", [val], false);\n            return '\"' + val.fontFamily + '\"';\n        } else {\n            return val;\n        }\n    },\n\n    // With animationName we look for an object that contains keyframes and\n    // inject them as an `@keyframes` block, returning a uniquely generated\n    // name. The keyframes object should look like\n    //  animationName: {\n    //    from: {\n    //      left: 0,\n    //      top: 0,\n    //    },\n    //    '50%': {\n    //      left: 15,\n    //      top: 5,\n    //    },\n    //    to: {\n    //      left: 20,\n    //      top: 20,\n    //    }\n    //  }\n    // TODO(emily): `stringHandlers` doesn't let us rename the key, so I have\n    // to use `animationName` here. Improve that so we can call this\n    // `animation` instead of `animationName`.\n    animationName: function animationName(val) {\n        if (typeof val !== \"object\") {\n            return val;\n        }\n\n        // Generate a unique name based on the hash of the object. We can't\n        // just use the hash because the name can't start with a number.\n        // TODO(emily): this probably makes debugging hard, allow a custom\n        // name?\n        var name = 'keyframe_' + (0, _util.hashObject)(val);\n\n        // Since keyframes need 3 layers of nesting, we use `generateCSS` to\n        // build the inner layers and wrap it in `@keyframes` ourselves.\n        var finalVal = '@keyframes ' + name + '{';\n        Object.keys(val).forEach(function (key) {\n            finalVal += (0, _generate.generateCSS)(key, [val[key]], stringHandlers, false);\n        });\n        finalVal += '}';\n\n        injectGeneratedCSSOnce(name, finalVal);\n\n        return name;\n    }\n};\n\n// This is a map from Aphrodite's generated class names to `true` (acting as a\n// set of class names)\nvar alreadyInjected = {};\n\n// This is the buffer of styles which have not yet been flushed.\nvar injectionBuffer = \"\";\n\n// A flag to tell if we are already buffering styles. This could happen either\n// because we scheduled a flush call already, so newly added styles will\n// already be flushed, or because we are statically buffering on the server.\nvar isBuffering = false;\n\nvar injectGeneratedCSSOnce = function injectGeneratedCSSOnce(key, generatedCSS) {\n    if (!alreadyInjected[key]) {\n        if (!isBuffering) {\n            // We should never be automatically buffering on the server (or any\n            // place without a document), so guard against that.\n            if (typeof document === \"undefined\") {\n                throw new Error(\"Cannot automatically buffer without a document\");\n            }\n\n            // If we're not already buffering, schedule a call to flush the\n            // current styles.\n            isBuffering = true;\n            (0, _asap2['default'])(flushToStyleTag);\n        }\n\n        injectionBuffer += generatedCSS;\n        alreadyInjected[key] = true;\n    }\n};\n\nvar injectStyleOnce = function injectStyleOnce(key, selector, definitions, useImportant) {\n    if (!alreadyInjected[key]) {\n        var generated = (0, _generate.generateCSS)(selector, definitions, stringHandlers, useImportant);\n\n        injectGeneratedCSSOnce(key, generated);\n    }\n};\n\nexports.injectStyleOnce = injectStyleOnce;\nvar reset = function reset() {\n    injectionBuffer = \"\";\n    alreadyInjected = {};\n    isBuffering = false;\n    styleTag = null;\n};\n\nexports.reset = reset;\nvar startBuffering = function startBuffering() {\n    if (isBuffering) {\n        throw new Error(\"Cannot buffer while already buffering\");\n    }\n    isBuffering = true;\n};\n\nexports.startBuffering = startBuffering;\nvar flushToString = function flushToString() {\n    isBuffering = false;\n    var ret = injectionBuffer;\n    injectionBuffer = \"\";\n    return ret;\n};\n\nexports.flushToString = flushToString;\nvar flushToStyleTag = function flushToStyleTag() {\n    var cssContent = flushToString();\n    if (cssContent.length > 0) {\n        injectStyleTag(cssContent);\n    }\n};\n\nexports.flushToStyleTag = flushToStyleTag;\nvar getRenderedClassNames = function getRenderedClassNames() {\n    return Object.keys(alreadyInjected);\n};\n\nexports.getRenderedClassNames = getRenderedClassNames;\nvar addRenderedClassNames = function addRenderedClassNames(classNames) {\n    classNames.forEach(function (className) {\n        alreadyInjected[className] = true;\n    });\n};\n\nexports.addRenderedClassNames = addRenderedClassNames;\n/**\n * Inject styles associated with the passed style definition objects, and return\n * an associated CSS class name.\n *\n * @param {boolean} useImportant If true, will append !important to generated\n *     CSS output. e.g. {color: red} -> \"color: red !important\".\n * @param {Object[]} styleDefinitions style definition objects as returned as\n *     properties of the return value of StyleSheet.create().\n */\nvar injectAndGetClassName = function injectAndGetClassName(useImportant, styleDefinitions) {\n    // Filter out falsy values from the input, to allow for\n    // `css(a, test && c)`\n    var validDefinitions = styleDefinitions.filter(function (def) {\n        return def;\n    });\n\n    // Break if there aren't any valid styles.\n    if (validDefinitions.length === 0) {\n        return \"\";\n    }\n\n    var className = validDefinitions.map(function (s) {\n        return s._name;\n    }).join(\"-o_O-\");\n    injectStyleOnce(className, '.' + className, validDefinitions.map(function (d) {\n        return d._definition;\n    }), useImportant);\n\n    return className;\n};\nexports.injectAndGetClassName = injectAndGetClassName;"]},"metadata":{},"sourceType":"script"}